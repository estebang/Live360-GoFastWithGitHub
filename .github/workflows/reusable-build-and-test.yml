# Reusable workflow for building and testing .NET applications
# This workflow can be called from other workflows to ensure consistent build and test processes
# across all environments and scenarios

name: Reusable Build and Test

on:
  workflow_call:
    inputs:
      # .NET version to use for building and testing
      dotnet-version:
        description: 'The .NET version to use'
        required: false
        type: string
        default: '9.0.x'
      
      # Build configuration (Debug or Release)
      configuration:
        description: 'Build configuration'
        required: false
        type: string
        default: 'Release'
      
      # Solution file path relative to repository root
      solution-path:
        description: 'Path to solution file'
        required: false
        type: string
        default: 'TailspinToys.sln'
      
      # Whether to upload code coverage reports
      upload-coverage:
        description: 'Upload code coverage to Codecov'
        required: false
        type: boolean
        default: true
      
      # Whether to run security scans
      run-security-scan:
        description: 'Run security vulnerability scans'
        required: false
        type: boolean
        default: true
      
      # Operating system to run on
      runs-on:
        description: 'Runner OS'
        required: false
        type: string
        default: 'ubuntu-latest'
    
    outputs:
      # Build artifacts information for downstream jobs
      build-version:
        description: 'Version of the built application'
        value: ${{ jobs.build-and-test.outputs.build-version }}
      
      # Test results summary
      test-results:
        description: 'Summary of test execution'
        value: ${{ jobs.build-and-test.outputs.test-results }}

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ${{ inputs.runs-on }}
    
    outputs:
      build-version: ${{ steps.version.outputs.version }}
      test-results: ${{ steps.test.outputs.test-results }}
    
    steps:
    # Checkout the source code
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # Fetch full history for better version generation
        fetch-depth: 0
    
    # Setup .NET SDK with the specified version
    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ inputs.dotnet-version }}
        
    # Cache NuGet packages to speed up builds
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Create cache key based on project files hash
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.fsproj', '**/*.vbproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
    
    # Generate version number based on Git history
    - name: Generate version
      id: version
      run: |
        # Use git describe to generate a version based on tags and commits
        if git describe --tags --exact-match HEAD >/dev/null 2>&1; then
          # We're on a tag, use the tag as version (assume it's properly formatted)
          VERSION=$(git describe --tags --exact-match HEAD)
          ASSEMBLY_VERSION=$VERSION
          FILE_VERSION=$VERSION
        else
          # Generate semantic version from latest tag + build number
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
          # Remove 'v' prefix if present
          LATEST_TAG=${LATEST_TAG#v}
          
          # Get commit count since last tag
          COMMIT_COUNT=$(git rev-list --count HEAD ^$(git describe --tags --abbrev=0 2>/dev/null || echo "HEAD~1000") 2>/dev/null || echo "0")
          
          # Get short commit SHA
          COMMIT_SHA=$(git rev-parse --short HEAD)
          
          # Generate versions
          VERSION="${LATEST_TAG}-dev.${COMMIT_COUNT}+${COMMIT_SHA}"
          ASSEMBLY_VERSION="${LATEST_TAG}.${COMMIT_COUNT}"
          FILE_VERSION="${LATEST_TAG}.${COMMIT_COUNT}"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "assembly-version=$ASSEMBLY_VERSION" >> $GITHUB_OUTPUT
        echo "file-version=$FILE_VERSION" >> $GITHUB_OUTPUT
        
        echo "Generated version: $VERSION"
        echo "Assembly version: $ASSEMBLY_VERSION"
        echo "File version: $FILE_VERSION"
    
    # Restore NuGet packages
    - name: Restore dependencies
      run: |
        echo "::group::Restoring NuGet packages"
        dotnet restore ${{ inputs.solution-path }} --verbosity minimal
        echo "::endgroup::"
    
    # Build the solution
    - name: Build solution
      run: |
        echo "::group::Building solution"
        dotnet build ${{ inputs.solution-path }} \
          --no-restore \
          --configuration ${{ inputs.configuration }} \
          --verbosity minimal \
          -p:Version="${{ steps.version.outputs.version }}" \
          -p:AssemblyVersion="${{ steps.version.outputs.assembly-version }}" \
          -p:FileVersion="${{ steps.version.outputs.file-version }}" \
          -p:InformationalVersion="${{ steps.version.outputs.version }}"
        echo "::endgroup::"
    
    # Run tests with code coverage collection
    - name: Run tests
      id: test
      run: |
        echo "::group::Running tests with coverage"
        dotnet test ${{ inputs.solution-path }} \
          --no-build \
          --configuration ${{ inputs.configuration }} \
          --verbosity normal \
          --collect:"XPlat Code Coverage" \
          --results-directory ./TestResults \
          --logger "trx;LogFileName=test-results.trx" \
          --logger "console;verbosity=detailed"
        
        # Generate test results summary
        TEST_COUNT=$(find ./TestResults -name "*.trx" -exec grep -o 'total="[0-9]*"' {} \; | head -1 | grep -o '[0-9]*' || echo "0")
        FAILED_COUNT=$(find ./TestResults -name "*.trx" -exec grep -o 'failed="[0-9]*"' {} \; | head -1 | grep -o '[0-9]*' || echo "0")
        PASSED_COUNT=$((TEST_COUNT - FAILED_COUNT))
        
        echo "test-results=Total: $TEST_COUNT, Passed: $PASSED_COUNT, Failed: $FAILED_COUNT" >> $GITHUB_OUTPUT
        echo "::notice title=Test Results::Total: $TEST_COUNT, Passed: $PASSED_COUNT, Failed: $FAILED_COUNT"
        echo "::endgroup::"
    
    # Parse test results and create summary
    - name: Parse test results
      if: always()
      run: |
        echo "::group::Test Results Summary"
        
        # Find TRX files and extract results
        TRX_FILES=$(find ./TestResults -name "*.trx" 2>/dev/null || true)
        
        if [ -n "$TRX_FILES" ]; then
          echo "Found test result files:"
          echo "$TRX_FILES"
          
          # Extract test counts from TRX files
          TOTAL_TESTS=0
          PASSED_TESTS=0
          FAILED_TESTS=0
          
          for file in $TRX_FILES; do
            if [ -f "$file" ]; then
              # Extract counts from TRX XML
              TOTAL=$(grep -o 'total="[0-9]*"' "$file" | grep -o '[0-9]*' | head -1 || echo "0")
              PASSED=$(grep -o 'passed="[0-9]*"' "$file" | grep -o '[0-9]*' | head -1 || echo "0")
              FAILED=$(grep -o 'failed="[0-9]*"' "$file" | grep -o '[0-9]*' | head -1 || echo "0")
              
              TOTAL_TESTS=$((TOTAL_TESTS + TOTAL))
              PASSED_TESTS=$((PASSED_TESTS + PASSED))
              FAILED_TESTS=$((FAILED_TESTS + FAILED))
            fi
          done
          
          # Create test summary
          echo "ðŸ“Š **Test Results Summary**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Total Tests | $TOTAL_TESTS |" >> $GITHUB_STEP_SUMMARY
          echo "| Passed | $PASSED_TESTS âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| Failed | $FAILED_TESTS âŒ |" >> $GITHUB_STEP_SUMMARY
          echo "| Success Rate | $(( TOTAL_TESTS > 0 ? (PASSED_TESTS * 100) / TOTAL_TESTS : 0 ))% |" >> $GITHUB_STEP_SUMMARY
          
          # Create notice
          if [ $FAILED_TESTS -eq 0 ]; then
            echo "::notice title=All Tests Passed::$TOTAL_TESTS tests passed successfully"
          else
            echo "::warning title=Test Failures::$FAILED_TESTS out of $TOTAL_TESTS tests failed"
          fi
          
          echo "Test Summary: Total=$TOTAL_TESTS, Passed=$PASSED_TESTS, Failed=$FAILED_TESTS"
        else
          echo "::warning::No test result files found"
          echo "âš ï¸ **No test results found**" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "::endgroup::"
    
    # Upload test results as artifacts for detailed analysis
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ github.run_id }}
        path: |
          ./TestResults/*.trx
          ./TestResults/**/coverage.cobertura.xml
          ./TestResults/**/coverage.opencover.xml
        retention-days: 30
    
    # Upload code coverage to Codecov
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      if: inputs.upload-coverage && (success() || failure())
      with:
        directory: ./TestResults
        files: '**/coverage.cobertura.xml'
        fail_ci_if_error: false
        token: ${{ secrets.CODECOV_TOKEN }}
        flags: unittests
        name: codecov-${{ github.run_id }}
    
    # Run security vulnerability scan using dotnet list package
    - name: Security vulnerability scan
      if: inputs.run-security-scan
      run: |
        echo "::group::Scanning for security vulnerabilities"
        # Check for known vulnerabilities in dependencies
        dotnet list ${{ inputs.solution-path }} package --vulnerable --include-transitive > vulnerability-report.txt 2>&1 || true
        
        # Check if vulnerabilities were found
        if grep -q "has the following vulnerable packages" vulnerability-report.txt; then
          echo "::warning title=Security Vulnerabilities::Vulnerable packages found. Check the full report."
          cat vulnerability-report.txt
        else
          echo "::notice title=Security Scan::No known vulnerabilities found in packages."
        fi
        echo "::endgroup::"
    
    # Run additional security checks with .NET analyzers
    - name: Run code analysis
      if: inputs.run-security-scan
      run: |
        echo "::group::Running static code analysis"
        # Run build with code analysis enabled
        dotnet build ${{ inputs.solution-path }} \
          --no-restore \
          --configuration ${{ inputs.configuration }} \
          --verbosity minimal \
          -p:RunAnalyzersDuringBuild=true \
          -p:TreatWarningsAsErrors=false \
          -p:WarningsAsErrors="" \
          -p:RunCodeAnalysis=true
        echo "::endgroup::"
    
    # Upload build artifacts for debugging if needed
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: build-logs-${{ github.run_id }}
        path: |
          **/*.log
          **/bin/**/*.dll
          **/bin/**/*.pdb
        retention-days: 5